local ULID = assert(foundation.com.ULID)
local assertions = assert(foundation.com.assertions)
local GuildMember = assert(hsw_guilds.GuildMember)
local GuildMemberInvite = assert(hsw_guilds.GuildMemberInvite)
local GuildRole = assert(hsw_guilds.GuildRole)

--- @namespace hsw_guilds

--- @class Guild
local Guild = foundation.com.Class:extends("hsw_guilds.Guild")
do
  local ic = Guild.instance_class

  --- Initializes a new Guild, the id will be autogenerated
  ---
  --- @spec #initialize(name: String, params: Table): void
  function ic:initialize(name, params)
    ic._super.initialize(self)

    --- @member visibility: "public" | "private"
    self.visibility = params.visibility or "private"

    --- @member id: String
    self.id = params.id or ULID.generate()

    --- @member name: String
    self.name = assert(name, "expected a name")

    --- A vanity ID is a readable "handle" that can be given to a guild, a simple string used to
    --- identify it in place of its ULID.
    --- Vanity IDs are formed from the name by removing all spaces typically
    ---
    --- @member vanity_id: String
    self.vanity_id = params.vanity_id or self:_generate_vanity_id()

    --- @member registered_at: Number
    self.registered_at = params.registered_at or core.get_gametime()

    --- @member founder: String
    self.founder = params.founder

    --- @member members: { [player_name: String]: GuildMember }
    self.members = {}

    --- @member invites: { [player_name: String]: GuildMemberInvite }
    self.invites = {}

    --- @member roles: { [role_id: String]: GuildRole }
    self.roles = {}

    --- @member m_expired_invites: Table
    self.m_expired_invites = {}

    --- @member m_invite_timer: Number
    self.m_invite_timer = 0
  end

  --- @spec #_generate_vanity_id(): void
  function ic:_generate_vanity_id()
    self.vanity_id = self.name:gsub(" ", ""):lower()
  end

  --- @spec #update(dtime: Float): void
  function ic:update(dtime)
    self.m_invite_timer = self.m_invite_timer + dtime
    if self.m_invite_timer > 1 then
      self.m_invite_timer = 0

      local gtime = core.get_gametime()
      local age
      for player_name, invite in pairs(self.invites) do
        age = invite.inserted_at - gtime
        if age >= hsw_guilds.INVITE_MAX_AGE then
          self.m_expired_invites[player_name] = true
        end
      end

      if next(self.m_expired_invites) then
        for player_name, _ in pairs(self.m_expired_invites) do
          self.invites[player_name] = nil
        end
        self.m_expired_invites = {}
      end
    end
  end

  --- Tries to add a new member to the guild, if the member already exists:
  --- false is returned, otherwise true and the GuildMember is returned instead
  ---
  --- @spec #add_member(player_name: String, member_data: Table): (Boolean, GuildMember)
  function ic:add_member(player_name, member_data)
    if self.members[player_name] then
      return false, mod.ERR_MEMBER_CONFLICT
    end

    local guild_member = GuildMember:new(player_name, member_data)
    guild_member.registered_at = core.get_gametime()
    self.members[player_name] = guild_member
    return true, guild_member
  end

  --- Apply given function to the guild member if they exist, does nothing otherwise.
  --- The function is expected to return the guild member.
  ---
  --- @spec #map_member(player_name: String, callback: function(GuildMember) => GuildMember):
  ---   (Boolean, GuildMember?)
  function ic:map_member(player_name, callback)
    local guild_member = self.members[player_name]

    if guild_member ~= nil then
      guild_member = callback(guild_member)
      self.members[player_name] = guild_member
      return true, guild_member
    end

    return false, mod.ERR_MEMBER_NOT_FOUND
  end

  --- @spec #update_member(player_name: String, member_data: Table)
  function ic:update_member(player_name, member_data)
    return map_member(player_name, function (guild_member)
      guild_member:update_data(member_data)
      return guild_member
    end)
  end

  --- @spec #remove_member(player_name: String, reason?: Any): Boolean
  function ic:remove_member(player_name, reason)
    local guild_member = self.members[player_name]
    if guild_member then
      guild_member:dispose(reason)
      self.members[player_name] = nil
      return true, guild_member
    end

    return false, mod.ERR_MEMBER_NOT_FOUND
  end

  --- @spec #get_member(player_name: String): GuildMember?
  function ic:get_member(player_name)
    return self.members[player_name]
  end

  --- Determines if a member exists in the guild
  ---
  --- @spec #has_member(player_name: String): Boolean
  function ic:has_member(player_name)
    return self.members[player_name] ~= nil
  end

  --- @spec #create_invite(
  ---   player_name: String,
  ---   role_id: String,
  ---   inviter: String
  --- ): (true, GuildMemberInvite) | (false, Error)
  function ic:create_invite(player_name, role_id, inviter)
    assertions.is_string(player_name, "expected a player name")

    if self.invites[player_name] then
      return false, mod.ERR_INVITE_CONFLICT
    end

    if self.members[player_name] then
      return false, mod.ERR_IS_MEMBER
    end

    local role = self.roles[role_id]
    if not role then
      return false, mod.ERR_ROLE_NOT_FOUND
    end

    local invite = GuildMemberInvite:new{
      player_name = player_name,
      inviter = inviter,
      role_id = role_id,
    }
    self.invites[player_name] = invite
    return true, invite
  end

  --- Regardless of the owner, delete the invite for ths specific user.
  ---
  --- @spec #delete_invite(player_name: String): (true, GuildMemberInvite) | (false, Error)
  function ic:delete_invite(player_name)
    local invite = self.invites[player_name]
    if invite then
      self.invites[player_name] = nil
      return true, invite
    end

    return false, mod.ERR_INVITE_NOT_FOUND
  end

  --- The original inviter of the invite can cancel it, if they change their mind.
  ---
  --- @spec #cancel_invite(
  ---   player_name: String,
  ---   inviter: String
  --- ): (true, GuildMemberInvite) | (false, Error)
  function ic:cancel_invite(player_name, inviter)
    local invite = self.invites[player_name]
    if invite then
      if invite.inviter == inviter then
        self.invites[player_name] = nil
        return true, invite
      else
        return false, mod.ERR_NOT_INVITER
      end
    end

    return false, mod.ERR_INVITE_NOT_FOUND
  end

  --- @spec #accept_invite(player_name: String): (true, GuildMemberInvite) | (false, Error)
  function ic:accept_invite(player_name)
    local invite = self.invites[player_name]
    if invite then
      self.invites[player_name] = nil
      -- we don't care about the return value here, though we probably should
      self:add_member(player_name, {
        invited_at = invite.inserted_at,
      })
      return true, invite
    end

    return false, mod.ERR_INVITE_NOT_FOUND
  end

  --- @spec #reject_invite(player_name: String): (true, GuildMemberInvite) | (false, Error)
  function ic:reject_invite(player_name)
    local invite = self.invites[player_name]
    if invite then
      self.invites[player_name] = nil
      return true, invite
    end

    return false, mod.ERR_INVITE_NOT_FOUND
  end

  --- @spec #create_role(role_id: String, params: Table): (true, GuildRole) | (false, Error)
  function ic:create_role(role_id, params)
    if self.roles[role_id] then
      return false, mod.ERR_ROLE_CONFLICT
    end

    local role = GuildRole:new(params)
    role.id = role_id
    self.roles[role_id] = role
    return true, role
  end

  --- @spec #remove_role(role_id: String): GuildRole
  function ic:remove_role(role_id)
    if self.roles[role_id] then
      local role = self.roles[role_id]
      self.roles[role_id] = nil
      return true, role
    end

    return false, mod.ERR_ROLE_NOT_FOUND
  end

  --- @spec #get_role(role_id: String): GuildRole | nil
  function ic:get_role(role_id)
    return self.roles[role_id]
  end

  --- @spec #dump(): Table
  function ic:dump()
    local members = {}
    for name, member in pairs(self.members) do
      members[name] = member:dump()
    end

    local invites = {}
    for name, invite in pairs(self.invites) do
      invites[name] = invite:dump()
    end

    local roles = {}
    for name, role in pairs(self.roles) do
      roles[name] = role:dump()
    end

    return {
      _v = 1,
      visibility = self.visibility,
      id = self.id,
      vanity_id = self.vanity_id,
      registered_at = self.id,
      founder = self.founder,
      name = self.name,
      members = members,
      invites = invites,
      roles = roles,
    }
  end

  --- @spec #load(data: Table): void
  function ic:load(data)
    if data._v == 1 then
      self.id = data.id
      self.vanity_id = data.vanity_id
      self.registered_at = data.registered_at
      self.founder = data.founder
      self.name = data.name

      local members = {}
      for name, member_data in pairs(data.members) do
        local member = GuildMember:alloc()
        member:load(member_data)
        members[name] = member
      end
      self.members = members

      local invites = {}
      for name, invite_data in pairs(data.invites) do
        local invite = GuildMemberInvite:alloc()
        invite:load(invite_data)
        invites[name] = invite
      end
      self.invites = invites

      local roles = {}
      for name, role_data in pairs(data.roles) do
        local role = GuildRole:alloc()
        role:load(role_data)
        roles[name] = role
      end
      self.roles = roles
    else
      error("cannot restore guild data version=" .. data._v)
    end
  end
end

hsw_guilds.Guild = Guild
