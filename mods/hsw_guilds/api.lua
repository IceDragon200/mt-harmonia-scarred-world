local mod = assert(hsw_guilds)

local ULID = assert(foundation.com.ULID)
local table_copy = assert(foundation.com.table_copy)
local assertions = assert(foundation.com.assertions)

--- @namespace hsw_guilds

--- @class GuildMember
local GuildMember = foundation.com.Class:extends("hsw_guilds.GuildMember")
do
  local ic = GuildMember.instance_class

  --- @spec #initialize(name: String, params: Table): void
  function ic:initialize(name, params)
    ic._super.initialize(self)

    params = params or {}
    --- @member name: String
    self.name = name
    --- @member role: String
    self.role = params.role or "member"
    --- @member registered_at: Number
    self.registered_at = params.registered_at or core.get_gametime()
    --- @member invited_at: Number
    self.invited_at = params.invited_at
  end

  --- @spec #dispose(reason: Any): void
  function ic:dispose(reason)
    --
  end

  --- @spec #update_data(Table): self
  function ic:update_data(data)
    if data.name then
      self.name = data.name
    end
    if data.role then
      self.role = data.role
    end
    return self
  end

  --- @spec #dump(): Table
  function ic:dump()
    return {
      _v = 1,
      name = self.name,
      role = self.role,
      registered_at = self.registered_at,
      invited_at = self.invited_at,
    }
  end

  --- @spec #load(data: Table): void
  function ic:load(data)
    if data._v == 1 then
      self.name = data.name
      self.role = data.role
      self.registered_at = data.registered_at
      self.invited_at = data.invited_at
    else
      error("cannot restore guild member data version=" .. data._v)
    end
  end
end

--- @class GuildMemberInvite
local GuildMemberInvite = foundation.com.Class:extends("hsw_guilds.GuildMemberInvite")
do
  local ic = GuildMemberInvite.instance_class

  --- @spec #initialize(): void
  function ic:initialize(params)
    ic._super.initialize(self)

    --- @member issuer: String
    self.issuer = params.issuer
    --- @member player_name: String
    self.player_name = params.player_name

    --- @member inserted_at: Number
    self.inserted_at = params.inserted_at or core.get_gametime()
  end

  --- @spec #dump(): Table
  function ic:dump()
    return {
      issuer = self.issuer,
      player_name = self.player_name,
      inserted_at = self.inserted_at,
    }
  end

  --- @spec #load(data: Table): void
  function ic:load(data)
    self.issuer = data.issuer
    self.player_name = data.player_name
    self.inserted_at = data.inserted_at
  end
end

--- @class Guild
local Guild = foundation.com.Class:extends("hsw_guilds.Guild")
do
  local ic = Guild.instance_class

  --- Initializes a new Guild, the id will be autogenerated
  ---
  --- @spec #initialize(name: String, params: Table): void
  function ic:initialize(name, params)
    ic._super.initialize(self)

    --- @member id: String
    self.id = params.id or ULID.generate()

    --- @member registered_at: Number
    self.registered_at = params.registered_at or core.get_gametime()

    --- @member founder: String
    self.founder = params.founder

    --- @member name: String
    self.name = assert(name, "expected a name")

    --- @member members: { [player_name: String]: GuildMember }
    self.members = {}

    --- @member invites: { [player_name: String]: GuildMemberInvite }
    self.invites = {}

    --- @member m_expired_invites: Table
    self.m_expired_invites = {}

    --- @member m_invite_timer: Number
    self.m_invite_timer = 0
  end

  --- @spec #update(dtime: Float): void
  function ic:update(dtime)
    self.m_invite_timer = self.m_invite_timer + dtime
    if self.m_invite_timer > 1 then
      self.m_invite_timer = 0

      local gtime = core.get_gametime()
      local age
      for player_name, invite in pairs(self.invites) do
        age = invite.inserted_at - gtime
        if age >= hsw_guilds.INVITE_MAX_AGE then
          self.m_expired_invites[player_name] = true
        end
      end

      if next(self.m_expired_invites) then
        for player_name, _ in pairs(self.m_expired_invites) do
          self.invites[player_name] = nil
        end
        self.m_expired_invites = {}
      end
    end
  end

  --- Tries to add a new member to the guild, if the member already exists:
  --- false is returned, otherwise true and the GuildMember is returned instead
  ---
  --- @spec #add_member(player_name: String, member_data: Table): (Boolean, GuildMember)
  function ic:add_member(player_name, member_data)
    if self.members[player_name] then
      return false, nil
    end

    local guild_member = GuildMember:new(player_name, member_data)
    guild_member.registered_at = core.get_gametime()
    self.members[player_name] = guild_member
    return true, guild_member
  end

  --- Apply given function to the guild member if they exist, does nothing otherwise.
  --- The function is expected to return the guild member.
  ---
  --- @spec #map_member(player_name: String, callback: function(GuildMember) => GuildMember):
  ---   (Boolean, GuildMember?)
  function ic:map_member(player_name, callback)
    local guild_member = self.members[player_name]

    if guild_member ~= nil then
      guild_member = callback(guild_member)
      self.members[player_name] = guild_member
      return true, guild_member
    end

    return false, nil
  end

  --- @spec #update_member(player_name: String, member_data: Table)
  function ic:update_member(player_name, member_data)
    return map_member(player_name, function (guild_member)
      guild_member:update_data(member_data)
      return guild_member
    end)
  end

  --- @spec #remove_member(player_name: String, reason?: Any): Boolean
  function ic:remove_member(player_name, reason)
    local guild_member = self.members[player_name]
    if guild_member then
      guild_member:dispose(reason)
      self.members[player_name] = nil
      return true, guild_member
    end

    return false, nil
  end

  --- @spec #get_member(player_name: String): GuildMember?
  function ic:get_member(player_name)
    return self.members[player_name]
  end

  --- Determines if a member exists in the guild
  ---
  --- @spec #has_member(player_name: String): Boolean
  function ic:has_member(player_name)
    return self.members[player_name] ~= nil
  end

  --- @spec #create_invite(player_name: String): (true, GuildMemberInvite) | (false, Error)
  function ic:create_invite(player_name)
    assertions.is_string(player_name, "expected a player name")

    if self.invites[player_name] then
      return false, "invite already exists"
    end

    local invite = GuildMemberInvite:new{
      player_name = player_name,
    }
    self.invites[player_name] = invite
    return true, invite
  end

  --- Regardless of the owner, delete the invite for ths specific user.
  ---
  --- @spec #delete_invite(player_name: String): (true, GuildMemberInvite) | (false, Error)
  function ic:delete_invite(player_name)
    local invite = self.invites[player_name]
    if invite then
      self.invites[player_name] = nil
      return true, invite
    end

    return false, "no invite exists for player"
  end

  --- The original issuer of the invite can cancel it, if they change their mind.
  ---
  --- @spec #cancel_invite(
  ---   player_name: String,
  ---   issuer: String
  --- ): (true, GuildMemberInvite) | (false, Error)
  function ic:cancel_invite(player_name, issuer)
    local invite = self.invites[player_name]
    if invite then
      if invite.issuer == issuer then
        self.invites[player_name] = nil
        return true, invite
      else
        return false, "not the player who issued the invite"
      end
    end

    return false, "no invite exists for player"
  end

  --- @spec #accept_invite(player_name: String): (true, GuildMemberInvite) | (false, Error)
  function ic:accept_invite(player_name)
    local invite = self.invites[player_name]
    if invite then
      self.invites[player_name] = nil
      -- we don't care about the return value here, though we probably should
      self:add_member(player_name, {
        invited_at = invite.inserted_at,
      })
      return true, invite
    end

    return false, "no invite exists for player"
  end

  --- @spec #reject_invite(player_name: String): (true, GuildMemberInvite) | (false, Error)
  function ic:reject_invite(player_name)
    local invite = self.invites[player_name]
    if invite then
      self.invites[player_name] = nil
      return true, invite
    end

    return false, "no invite exists for player"
  end

  --- @spec #dump(): Table
  function ic:dump()
    local members = {}
    for name, member in pairs(self.members) do
      members[name] = member:dump()
    end

    local invites = {}
    for name, invite in pairs(self.invites) do
      invites[name] = invite:dump()
    end

    return {
      _v = 1,
      id = self.id,
      registered_at = self.id,
      founder = self.founder,
      name = self.name,
      members = members,
      invites = invites,
    }
  end

  --- @spec #load(data: Table): void
  function ic:load(data)
    if data._v == 1 then
      self.id = data.id
      self.registered_at = data.registered_at
      self.founder = data.founder
      self.name = data.name

      local members = {}
      for name, member_data in pairs(data.members) do
        local member = GuildMember:alloc()
        member:load(member_data)
        members[name] = member
      end
      self.members = members

      local invites = {}
      for name, invite_data in pairs(data.invites) do
        local invite = GuildMemberInvite:alloc()
        invite:load(invite_data)
        invites[name] = invite
      end
      self.invites = invites
    else
      error("cannot restore guild data version=" .. data._v)
    end
  end
end

--- @class Guilds
local Guilds = foundation.com.Class:extends("hsw_guilds.Guilds")
do
  ic = Guilds.instance_class

  --- Initializes the Guilds management system.
  ---
  --- @spec #initialize(): void
  function ic:initialize()
    ic._super.initialize(self)

    --- @member registered_guilds: { [guild_name: String]: Guild }
    self.registered_guilds = {}

    --- A table containing all known guild members.
    ---
    --- @member known_members: { [player_name: String]: { [guild_name: String]: Boolean } }
    self.known_members = {}
  end

  --- @spec #update(dtime: Float): void
  function ic:update(dtime)
    for _, guild in pairs(guilds) do
      guild:update(dtime)
    end
  end

  --- Attempts to register the specified guild, the name should be the display name
  --- of the guild, the id will be derived from the guild name
  ---
  --- @spec #try_register_guild(name: String, params: Table): (success: Boolean, Guild?)
  function ic:try_register_guild(name, params)
    assert(type(name) == "string", "expected a guild name")
    assert(type(params) == "table", "expected some parameters")

    if self.registered_guilds[name] then
      return false, nil
    end

    local guild = Guild:new(name, params)
    guild.registered_at = core.get_gametime()
    self.registered_guilds[guild.id] = guild

    return true, guild
  end

  --- @spec #try_register_player_guild(player_name: String, guild_name: String, params: Table):
  ---   (success: Boolean, Guild?)
  function ic:try_register_player_guild(player_name, guild_name, params)
    if self.known_members[player_name] then
      -- the player is already a member of a guild
      -- TODO: return a error table notifying the caller what exactly happened
      return false, nil
    end

    local success, guild_or_error = self:try_register_guild(guild_name, params)

    if success then
      local guild = guild_or_error
      guild.founder = player_name
      -- should always be successful
      assert(self:set_guild_founder(guild.id, player_name))

      local member
      success, member = self:add_player_to_guild(player_name, guild_id, { role = "leader" })
      assert(success, "expected to add player as leader of guild")
      assert(member.role == "leader", "expected member to be leader")

      return true, guild
    end

    return success, guild_or_error
  end

  --- Sets the name of the founding player on the guild.
  ---
  --- @spec #set_guild_founder(guild_id: String, founder_name: String): (success: Boolean, Guild?)
  function ic:set_guild_founder(guild_id, founder_name)
    local guild = self.registered_guilds[guild_id]

    if guild then
      guild.founder = founder_name
      return true, guild
    end

    return false, nil
  end

  --- @spec #add_player_to_guild(player_name: String, guild_id: String, params: Table):
  ---   (success: Boolean, GuildMember?)
  function ic:add_player_to_guild(player_name, guild_id, params)
    local guild = self.registered_guilds[guild_id]

    if guild then
      local success, guild_member = guild:add_member(player_name, params)

      if success then
        if not self.known_members[player_name] then
          self.known_members[player_name] = {}
        end
        self.known_members[player_name][guild_id] = true
      end

      return success, guild_member
    end

    return false, nil
  end

  --- @spec #remove_player_from_guild(player_name: String, guild_id: String, reason: Any):
  ---   (success: Boolean, GuildMember?)
  function ic:remove_player_from_guild(player_name, guild_id, reason)
    local known_member = self.known_members[player_name]
    if known_member then
      if known_member[guild_id] then
        local success, guild_member =
          self.registered_guilds[guild_id]:remove_member(player_name, reason)

        if success then
          known_member[guild_id] = nil
          if not next(known_member) then
            self.known_members[player_name] = nil
          end
        end

        return success, guild_member
      end
    end

    return false, nil
  end

  --- @spec #is_player_in_guild(player_name: String, guild_id: String): Boolean
  function ic:is_player_in_guild(player_name, guild_id)
    local known_member = self.known_members[player_name]

    if known_member then
      return known_member[guild_id] == true
    end

    return false
  end

  --- @spec #get_player_primary_guild(player_name: String): Guild?
  function ic:get_player_primary_guild(player_name)
    local known_member = self.known_members[player_name]

    if known_member then
      local guild_id, bool = next(known_member)

      if bool then
        return self.registered_guilds[guild_id]
      end
    end

    return nil
  end

  --- @spec #invite_player_to_guild(
  ---   player_name: String,
  ---   guild_id: Guild
  --- ): (Boolean, GuildMemberInvite)
  function ic:invite_player_to_guild(player_name, guild_id)
    local guild = self.guilds[guild_id]
    if guild then
      return guild:create_invite(player_name)
    end

    return false, "guild not found"
  end

  --- @spec #delete_player_invite_to_guild(
  ---   player_name: String,
  ---   guild_id: Guild
  --- ): (Boolean, GuildMemberInvite)
  function ic:delete_player_invite_to_guild(player_name, guild_id)
    local guild = self.guilds[guild_id]
    if guild then
      return guild:delete_invite(player_name)
    end

    return false, "guild not found"
  end

  --- @spec #cancel_player_invite_to_guild(
  ---   issuer: String,
  ---   player_name: String,
  ---   guild_id: Guild
  --- ): (Boolean, GuildMemberInvite)
  function ic:cancel_player_invite_to_guild(issuer, player_name, guild_id)
    local guild = self.guilds[guild_id]
    if guild then
      return guild:cancel_invite(player_name, issuer)
    end

    return false, "guild not found"
  end

  --- @spec #accept_player_invite_to_guild(
  ---   player_name: String,
  ---   guild_id: Guild
  --- ): (Boolean, GuildMemberInvite)
  function ic:accept_player_invite_to_guild(player_name, guild_id)
    local guild = self.guilds[guild_id]
    if guild then
      return guild:accept_invite(player_name)
    end

    return false, "guild not found"
  end

  --- @spec #reject_player_invite_to_guild(
  ---   player_name: String,
  ---   guild_id: Guild
  --- ): (Boolean, GuildMemberInvite)
  function ic:reject_player_invite_to_guild(player_name, guild_id)
    local guild = self.guilds[guild_id]
    if guild then
      return guild:reject_invite(player_name)
    end

    return false, "guild not found"
  end

  --- @spec #dump(): Table
  function ic:dump()
    local known_members = {}
    local registered_guilds = {}
    for player_name, known_member in pairs(self.known_members) do
      known_members[player_name] = table_copy(known_member)
    end
    for id, guild in pairs(self.registered_guilds) do
      registered_guilds[id] = guild:dump()
    end
    return {
      registered_guilds = registered_guilds,
      known_members = known_members,
    }
  end

  --- @spec #load(data: Table): void
  function ic:load(data)
    local registered_guilds = {}
    local known_members = {}
    for guild_id, guild_data in pairs(registered_guilds) do
      local guild = Guild:alloc()
      guild:load(guild_data)
      registered_guilds[guild_id] = guild
    end
    for player_name, known_member in pairs(data.known_members) do
      known_members[player_name] = table_copy(known_member)
    end
    self.registered_guilds = registered_guilds
    self.known_members = known_members
  end
end

hsw_guilds.GuildMember = GuildMember
hsw_guilds.Guild = Guild
hsw_guilds.Guilds = Guilds
